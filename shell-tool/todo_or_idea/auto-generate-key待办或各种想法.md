首次部署：
确认具体哪些节点组成一个免密节点组，父脚本在任何一个节点上运行后，生成预设节点组中的其他节点可用的子脚本，
在节点组的其他节点中都运行过子脚本后，在父脚本中进行本组互联测试，全部免密连接成功后，父脚本将删除免密组内所有子脚本并将自己复制到所有组内其他节点中，至此完成此节点组的部署
如果有失败的连接，重试三次，还失败则记录情况，格式可以用： x-x-x-x:y-y-y-y  这是有反向的测试的，也要记录，最终测试完成后生成一个失败记录组信息，并在默认 /root 目录
之后需要人工检查问题，排除问题后，使用增加单个或多个节点进行增加，


免密节点组增加单个或多个节点：
在免密节点组中任意一个节点中运行父脚本，此父脚本将主动连接其他所有组内节点，将新增的节点信息增加到这些节点中，之后生成子脚本，
将子脚本在那些新增的节点中运行即可，之后有父脚本的节点中运行一次父脚本，


免密节点组删除单个或多个节点：
在免密节点组中任意一个节点中运行父脚本，此父脚本将主动连接其他所有组内节点，将准备删除的节点信息从组内节点中删除，之后去需要删除的节点中删除所有部署的公密钥和其他节点信息，
sshd_config中删除引用最后断开连接后删除本机中的连接信息

修改和查询节点信息


批量更新父脚本
给个选项，检测到后自动检测组内所有节点连接情况，确认没有连不上的节点后，将本机新版本父脚本发送到所有其他节点上

批量更新公密钥
需要手动运行，因为网络问题可能会失效，所以不能做成定时自动更新
给个选项，检测到后自动生成新的公密钥到备份的地方，然后自动检测组内所有节点连接情况，
确认没有连不上的节点后，本机连上所有其他的组内节点，
然后删掉那些文件，更新成新的文件，之后断开连接，依次操作直到完成所有节点的公密钥信息更新，
然后再删除本机公密钥，将新版本的覆盖过去，然后重新发起组内所有节点的连接测试，确认所有设备连接成功，则完成更新

手动连接节点功能
（比如首次部署的时候不想每次物理磁盘复制子脚本到目标节点硬件中，则可以用此功能连接）
前提是知道节点的密码，然后每次连接的时候需要手动输入密码完成连接并实现文件传输目的，

全量卸载：
运行父脚本的节点先连接所有免密节点，然后删除各自的连接信息，然后重启sshd，断开链接，等其他所有节点都删除后，再删除本机的配置信息


增减节点、批量更新脚本和公密钥和卸载功能都需要连接所有节点，所以独立出连接为模块以复用，
删除节点和卸载免密应该共享远程控制卸载连接配置的功能，需要独立出模块

增加公钥定向：
```bash
DEFAULT_PARAMETERS=$(grep -o 'AuthorizedKeysFile.*' /etc/ssh/sshd_config|sed -e 's/\ $//g; s/\//\\\//g')
sed -i -e "s/^AuthorizedKeysFile/#AuthorizedKeysFile/; /AuthorizedKeysFile/a\\${DEFAULT_PARAMETERS} .ssh\/ssh_auto_generate_authorized_keys" -e '/^#AuthorizedKeysFile/d' /etc/ssh/sshd_config
```


免密组：数据库
各种节点信息：多张表
节点选项：一个字段
节点选项值：一个字段的值

组：
增：create table 组名1,组名2(test),组名3            带括号的中间的内容为非root用户的名称，没有括号就默认当root对待，需要对括号全半角进行判断，逗号判断发现全角就报错，非root用户会找是否存在这个用户：cat /etc/passwd|awk -F ':' '{print $1,$6}'  1用户名，6默认家目录
删：drop table 组名1,组名2(test),组名3        非root用户的连接需要指定用户名
drop table if exists 组名1,组名2(test),组名3  
改：无
查：show tables


节点：
增：INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );
删：delete from student where NAME=ax119
delete from student where NAME in(ax108,ax119)
delete from student where NAME not in(ax108,ax119)
改：
查： select * from 组名 where NAME=ax108


>以下需要重新修改，最好是创建组的时候就给每个组对应的文件夹中放入一个标记文件，所以一切正常的话，每个组中都包含这个文件且内容相同，每次只需要比对 .ssh 中和对应组中的文件内容是否相同即可

要在.ssh下放置一个隐藏文件： .never_delete_this  里面内容（均用 # 注释掉）： 
```shell
# 生成此文件的工具全名为: Auto deploy key pair tool ，按照预设，此文件存放在/root/路径下，
# 名称为: .auto-deploy-key-pair-tool，并在 /usr/bin/ 下生成了一个软链接为 kpt ，作者名: Ou Yang Jian Yu
# 每次用 kpt 创建的业务组都将在 /root/.ssh 中生成对应名称的文件夹，并在 .never_delete_this 中增加一行业务组名称
# 每次用 kpt 删除的业务组都将从此文件中删除对应业务组名称

# 此文件和 /root/.ssh 中通过 kpt 自动生成的文件夹（非第三者人为手动添加的文件夹）只能通过kpt特定功能进行删除，
# 绝不能手动删，所有 Ou Yang Jian Yu 所写的跨服自动化脚本均会检测此文件是否存在以确认是否可以运行之后的功能，
# 所有已部署的免密节点组的业务所用各自公密钥均存储在这些自动生成的文件夹中，
# 一旦删除此文件将导致所有跨服自动化功能并在所有节点终端中生成报错，如果正常免密的话只是生成报错但不会停止功能
# 一旦误删此文件中包含的业务组名称对应的文件夹，将在所有失效的节点终端中生成报错
# 后来登录终端的所有用户都会看到此报错，以下未注释的部分每行均对应一个免密组的业务名
# 为了安全性，此隐藏文件将通过硬链接的方式生成多个备份，
# 一旦此文件被删除，其他文件还能正常作为指引并在自动化脚本工作时自动修复报错
# 默认在/ /root /usr/bin中生成，如果这些路径不同盘的话，会自动检测并尝试在同盘路径下随机生成包括本体在内总共三个分身
# 如果三个分身均被删除，将在全体已部署 Ou Yang Jian Yu 所写的自动化脚本且对应的免密组的节点中集体报错并停止全部功能
```

检测是否同挂载点的操作：
```bash
[root@108:/root]# stat -c '%d %m' /root
2051 /
[root@108:/root]# stat -c '%d %m' /
2051 /
```

需要检测一下.ssh这个目录的挂载点，然后检测下这个一层目录下是否存在超过两个文件夹，包括挂载点本身算一个，如果超过的话就继续部署



cat ~/.ssh/id_rsa.pub | ssh USER@HOST "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
传送公钥的方式参考






安装需要节点组名和节点信息（别名、用户名、ip、端口号），-y 执行
卸载:
卸载节点: 节点组名和节点别名，-y 执行
卸载节点组: 节点组名




将同步和scp功能拆开

scp：
将本地源路径设置成远程路径，对原路径进行判断是否存在必须备份的文件夹或文件
如果存在才开始执行备份，如果都不存在则报错退出

同步：
对比两目标路径（各自指定）的文件名，如果存在a服中有但b服中没有的则a传b，否则b传a，各自一个返回内容为列表做对比。


灾备：




超时的时间过了以后如果文件正常上传，希望继续上传，考虑在超时后开始计算md5值


增加一个用户指定特征信息的定位功能
增加一个用户指定特征信息的排除功能


正常ssh免密结构是：
.ssh
    config文件
    节点组1
        节点组1_authorized_keys 节点名a_config 节点组1_key 节点名b_config .auto_generate
    节点组2
        节点组2_authorized_keys 节点名a_config 节点组2_key 节点名b_config .auto_generate

I suggest to use option -O to append to your array:

mapfile -t -O "${#managed_policies[@]}" managed_policies < <(aws ...)



同步和备份的流程找不同：
同步(按日期排序的要么是纯文件，要么是纯文件夹)：

纯文件夹：
1. 获取始末节点各自指定路径下层级为 1 的所有文件夹名（排除指定的路径，即父路径）组成数组 **源1夹** **目的1夹**
2. 对 **源1夹**  **目的1夹** 名称进行遍历，每个循环先将
3. 根据用户指定的允许搜索的最早日期距离今日的最大天数进行循环，每循环一次日期倒退一天，检测出的日期格式对应替换成具体日期，之后对 **源1夹**  **目的1夹** 名称（分两段循环）进行遍历，找到与给定日期相同的对应文件夹名称存储到始末节点各自新的数组 **二筛源1夹** **二筛目的1夹**，其中对这俩数组最后进行判断，各自内置一个 JUMP 和各自 MARK 标记切换，在循环许可天数内，如果某日期下两段子循环结束的时候， **二筛源1夹** **二筛目的1夹** 任意一个数组已经获取到元素，则直接 JUMP=1 跳出循环，外部检测如果源和目标同步节点同日期 MARK 标记都为 1 则加入正常日志中，否则增加到警告日志中。

4. 对 **二筛源1夹** **二筛目的1夹** 进行遍历，获取数组中每个文件夹下无限层级的文件夹名（排除 **二筛源1夹** **二筛目的1夹** 本身）并添加到数组 **源无限夹** **目的无限夹**，获取数组 **二筛源1夹** **二筛目的1夹** 中每个文件夹下无限层级文件夹中的文件名并添加到数组 **源无限文** **目的无限文**
5. 对数组 **源无限夹** **目的无限夹** 相互内外套循环，内部进行对比，内部缺少的就是需要创建的文件夹，保存到正反向共两个新数组 ***锁定始到末夹***  ***锁定末到始夹***，即始末两套循环使得始末节点文件夹结构完全相同
6. 对数组 **源无限文** **目的无限文** 相互内外套循环，内部进行对比，内部找不到的就是缺少的文件要添加到新数组，内部找到则对比 sha256sum 值，相同则写入正常日志，不同则直接写入冲突日志，则两套循环下来共有两数组 ***锁定源无限文需传送*** ***锁定目的无限文需传送***
7. 开始传送 ***锁定源1文需传送*** ***锁定目的1文需传送*** 和 ***锁定源无限文需传送*** ***锁定目的无限文需传送***
8. 传送完成后将始末节点文件对比hash，相同则写入正常日志，不同则写入新数组 **重传文件** ，将 **重传文件** 重命名成 **准备传送**
9.  遍历 **准备传送** 进行重新传送，


纯文件：

1. 获取始末节点各自指定路径下层级为 1 的所有文件名组成数组 **源1文** **目的1文**
2. 对 **源1文** **目的1文** 名称进行遍历
3. 根据用户指定的允许搜索的最早日期距离今日的最大天数进行循环，每循环一次日期倒退一天，每次获取的日期对 **DATE_TYPE** 进行赋值，之后对 **源1夹**  **目的1夹** 和 **源1文** **目的1文** 名称（分四段循环）进行遍历，找到与给定日期相同的对应文件或文件夹名称存储到始末节点各自新的数组 ***锁定源1文需传送*** ***锁定目的1文需传送*** 和 **二筛源1夹** **二筛目的1夹**，其中对这俩数组先进行判断，内置一个mark切换，在循环许可天数内如果某个日期下非空则直接mark1跳出循环，如果mark是0则增加到警告日志中。

4. 对 **二筛源1夹** **二筛目的1夹** 进行遍历，获取数组中每个文件夹下无限层级的文件夹名（排除 **二筛源1夹** **二筛目的1夹** 本身）并添加到数组 **源无限夹** **目的无限夹**，获取数组 **二筛源1夹** **二筛目的1夹** 中每个文件夹下无限层级文件夹中的文件名并添加到数组 **源无限文** **目的无限文**
5. 对数组 **源无限夹** **目的无限夹** 相互内外套循环，内部进行对比，内部缺少的就是需要创建的文件夹，保存到正反向共两个新数组 ***锁定始到末夹***  ***锁定末到始夹***，即始末两套循环使得始末节点文件夹结构完全相同
6. 对数组 **源无限文** **目的无限文** 相互内外套循环，内部进行对比，内部找不到的就是缺少的文件要添加到新数组，内部找到则对比 sha256sum 值，相同则写入正常日志，不同则直接写入冲突日志，则两套循环下来共有两数组 ***锁定源无限文需传送*** ***锁定目的无限文需传送***
7. 开始传送 ***锁定源1文需传送*** ***锁定目的1文需传送*** 和 ***锁定源无限文需传送*** ***锁定目的无限文需传送***
8. 传送完成后将始末节点文件对比hash，相同则写入正常日志，不同则写入新数组 **重传文件** ，将 **重传文件** 重命名成 **准备传送**
9.  遍历 **准备传送** 进行重新传送，








备份：
1. 获取源节点指定路径下的所有文件并保存成数组 **源夹**
2. 将整个文件夹通过scp传送到目标节点指定路径
3. 对目标节点指定路径find获取所有文件路径并保存成数组 **目的夹**
4. 以源节点路径为准，对目标路径数组进行比对，如果存在源节点有但目标节点没有的，则保存到新数组 **重传** ；如果始末节点都有则对比校验值，如果值相同则跳过，值不同则保存到新数组 **重传** 
5. 创建一个循环，内部对数组 **重传** 重命名成 **剩余** ，对目标节点的 **剩余** 进行遍历，


安装 
需要：安装节点名，组名、


卸载
需要：卸载节点名、操作别名，如果是all，则彻底卸载，否则只删除对应定时任务